JAVASCRIPT
====================================================
수업 js
====================================================

<script>
        // 배열 
        const arr = [40,20,30,'40',11];
        console.log(arr);
        // 자바스크립트 객체를 하나하나 다 볼 수 있다 -> console.log을 장점

        arr.sort();

        // () -> 매개변수를 나타냄
        // 자바스크립트의 arrow function

        // func1은 요소와 인덱스를 콘솔로그에 출력해주라는 함수이다
        const func1 = (element,index) => {
            console.log(element,index)
        };

        // 이제 func1이 arr배열을 돌면서 요소와 인덱스를 콘솔로그에 출력하게 된다
        arr.forEach(func1)
        
        // document에서 selctorAll 하겠다 .image라는 selector를 
        // .image를 가져온다
        const imageList = document.querySelectorAll('.image')
        // 콘솔로그로 출력한다
        console.log(imageList)

        // foreach를 통해서 .image로 가져온 요소에 스타일 한번에 적용할 수 있다
        imageList.forEach(img => {      // 화살표 함수의 매개변수가 1개라면 () 생략 가능
            img.style.border = '3px soild black'
        });
        // 문서의 특정요소를 불러와서 한꺼번에 작업을 진행할 수 있다

        // 화살표 함수의 실행 코드가 한줄이라면 ()생략 가능

        //imageList.forEach(img => img.style.borderRadius = '50%')

        imageList.forEach(img => img.style.borderRadius = '70px')
        // 이렇게 하면 이미지에는 인라인스타일로 적용이 된다
    </script>

====================================================

    <script>
        // css 선택자를 이용해서 요소를 불러올 수 있다

        document.getElementById('id')           // 지정한 id를 가지느 요소 하나를 반환
        document.querySelector('css선택자')     // 지정한 선택자에 해당하는 요소 중 첫번째 요소 하나만
        document.querySelectorAll('css선택자')  // 지정한 선택자에 해당하는 모든 요소를 nodeList로 반환
        
        // 1) 이름 나이 전화번호가 적혀있는 첫번째 줄의 칸 배경색을 #dadada로 변경하기
        const headList = document.querySelector('thead')
        

        // for(let i = 0; i < headList.length; i++){
        //  const th = headList[i]
        //  th.style.backgroundColor = '#dadada'
        //} -> 기본 for문으로 돌려도 된다
        console.log(headList)

        // css에서 하이픈을 사용하려면 여기서는 camelCase를 적용해서 해야한다
        // don`t forget camelCase
        // 단일 객체이기 때문에 foreach문을 돌리지 않고 단독으로 style을 준 것이다
        headList.style.backgroundColor = '#dadada'

        // 2) 각 나이가 적혀있는 칸을 불러와서 내부 텍스트에 '살' 이라는 문자를 추가한다

        const ageList = document.querySelectorAll('tbody>tr>td:nth-child(2)')

        console.log(ageList)

        ageList.forEach(td => {
            td.style.color = 'blue'
            td.style.textAlign = 'center'
            td.innerText += '살'  //ㄴ-> 기존의 것에 살을 더해주는 것이다
            //td.append('살')
        })
        // 3) 전화번호가 적혀있는 칸에 마우스를 올리면 링크처럼 손가락모야응로 나타나도록 설정하세요
    
        const cursor = document.querySelectorAll('tbody>tr>td:nth-child(3)')

        console.log(cursor)

        cursor.forEach(td =>{
            td.style.cursor = 'pointer'
            td.style.textDecoration = 'underline'
        })

        // 4) 이름 bold 처리

        const nameList = document.querySelectorAll('tbody>tr>td:nth-child(1)')

        console.log(nameList)

        nameList.forEach(td =>{
            td.style.fontWeight = 'bolder'
        })
    </script>
====================================================

    <input type="text" name="name" placeholder="이름">
    <input type="button" value="추가">
    <div class="list"></div>

    <script>
        const button = document.querySelector('input[type="button"]')
        const name = document.querySelector('input[name="name"]')
        const list = document.querySelector('.list')

        // 해당 물품의 옵션을 추가해줄 때 사용된다
        button.onclick = () => {
            const text = name.value                 // input에 입력된 글자를 저장해두고
            const p = document.createElement('p')   // p태그 요소를 하나 만들고

            p.innerText = text                      // p태그의 내부 글자에 text를 넣고
            p.style.fontWeight = 'bold'
            list.appendChild(p)                     // p를 list에 자식 요소로 추가하고
            name.value = ''                         // 입력받은 input의 value를 없애고 (글자 지우기)
            name.focus()                            // 다시 입력받기 편하게 input에 focus()를 실행
        }
    </script>
====================================================

    <p>이름<input type="text" name="name" id="name"></p>
    <p>나이<input type="number" name="age" id="age"></p>
    <p>출생년도<input type="number" name="year" id="year"></p>
    <p><button id="btn">입력</button></p>
    <div class="result"></div>

    <script>
        // id를 이요해서 요소 불러오기
        const name = document.getElementById('name')
        // css선택자를 이용해서 요소 불러오기
        const age = document.querySelector('#age')

        const year = document.getElementById('year')

        const btn = document.getElementById('btn')
        const result = document.querySelector('.result')

        console.log(btn)            // HTML 태그만 출력
        console.log({'btn' : btn})  // HTML 요소의 내부 상세 정보를 출력

        const btnHandler = (event) => {  // [버튼을 클릭하면] 작동하게 만들 함수를 작성
            console.log(event)
            console.log(event.target)

            console.log(name.value)     // element.property 요소.속성의 형식으로 값에 접근할 수 있다
            console.log(age.value)
            console.log(year.value)
            console.log(name.type)

            if(name.value == '' || age.value == '' || year.value==''){
                alert('모든 값을 입력해주세요')
                return
            }

            // 이 방식은 이클립스에서 사용이 불가능하다
            const str = `${name.value}님은 ${year.value}생이고 ${age.value}살이고, ${age.value >= 20 ? '성인' : '미성년자'}입니다`

            result.innerText = str
            // == : 타입이 달라도, 값의 형태가 일치하면 일치로 판단
            // === : 타입도 같고, 값도 같아야 일치로 판단

            const str2 = name.value + '님은' +
                        age.value + '살이고, '+
                        (age.value >= 20 ? '성인' : '미성년자') + '입니다'
            
            alert(str2)
        }

        btn.onclick = btnHandler    // 버튼을 클릭하면 지정한 함수가 실행되도록
                                    // 함수를 지금 호출하는 것이 아니므로, btnHandler()형식이 아니다
        // 콘솔로그창에 PointerEvent가 발생한다

    </script>
====================================================

    <script>
        // 정수를 입력받아서 자릿수를 거구로 배치하고 result태그 내 출력하기
        const num = document.getElementById('num')
        const btnStr = document.getElementById('btnStr')
        const btnNum = document.getElementById('btnNum')
        const result = document.querySelector('.result')

        const btnHandler = (event) =>{
            // num.value의 값도 let으로 만들어서 사용해야 한다
            let value = +num.value    // Integer.parseInt(value)랑 동일함
            let ans = 0                 // 값을 변경해야 하므로 let

            console.log(value)
        
            while(true){
                ans += (value % 10)
                ans *= 10
                value /= 10                 // /= 을 안해줌
                value = Math.floor(value)   // 소수점을 버리는 함수
                if(value < 10){
                    ans += value
                    break
                }
            }
            
            // ans += (num.value % 10)
            // console.log(ans)

            // ans *= 10
            // console.log(ans)

            // ans += (num.value / 10)

            // console.log(num.value)

            // if(num.value < 10){
            //     ans += num.value
            // }

            console.log(value)
            console.log(ans)


            const str = ans + '입니다'
            
            result.innerText = str
        }

        btnNum.onclick = btnHandler
        

        btnStr.onclick = () => {
            const value = num.value
            var name = num.value
            var reverseName = name.split('').reverse().join('')
            // 입력받은 문자열을 글자하나씩 구분해서 뒤집고
            // 다시 연결해서 하나의 문자열로 만듦

            result.innerText = ''   // innerText안에 한번 비워주기
            
            for(let i = value.length-1; i > 0; i--){
                console.log(value[i])
                result.innerText += value[i]
            }
            // 뒤에서부터 한글자씩 result.innerText로 넣는다
            console.log(reverseName)
        }
    </script>
====================================================

   <script>
        const tbody = document.querySelector('tbody')
        const btn = document.querySelector('input[type="button"]')

        const btnClick = () => {
            const name = document.querySelector('input[name="name"]')
            const pnum = document.querySelector('input[name="pnum"]')
            const gender = document.querySelector('input[name="gender"]:checked')

            let tr = document.createElement('tr')
            let td1 = document.createElement('td') 
            let td2 = document.createElement('td') 
            let td3 = document.createElement('td') 

            td1.innerText = name.value
            td2.innerText = pnum.value
            td3.innerText = gender.value

            tr.appendChild(td1)
            tr.appendChild(td2)
            tr.appendChild(td3)
            
            tbody.appendChild(tr)

            name.value = ''
            pnum.value = ''
            gender.checked = ''
            
            name.focus()
        }

        btn.onclick = btnClick
    </script>
====================================================

const buttonClickHander = () => {
    const name = document.querySelector('input[name="name"]')
    const pnum = document.querySelector('input[name="pnum"]')
    const gender = document.querySelector('input[name="gender"]:checked')
    
    
    let tr = document.createElement('tr')
                
    let td1 = document.createElement('td')
    td1.innerText = name.value

    let td2 = document.createElement('td')
    td2.innerText = pnum.value

    let td3 = document.createElement('td')
    td3.innerText = gender.value
    
    tr.appendChild(td1)
    tr.appendChild(td2)
    tr.appendChild(td3)
    // tbody를 안불러와서 못 넣었던 거
    tbody.appendChild(tr)

    console.log(name.value)
    console.log(pnum.value)
    console.log(gender.value)
    // name.value = ''          // 입력값 지우기
    // pnum.value = ''          // 입력값 지우기
    //gedner.checked = ''     // 선택한 상태 지우기   
    name.focus()              // 입력이 끝나면 이름으로 다시 돌아온다
}
====================================================


// 필요한 요소 불러오기
const children = document.querySelector('.form').children
console.log(children)

const button = document.querySelector('input[type="button"]')
const tbody = document.querySelector('tbody')


// 호출 함수 선언
const buttonClickhandler = () =>{
    const product = document.querySelector('input[name="product"]')
    const price = document.querySelector('input[name="price"]')
    // category 자체가 value를 포함하기 때문에 문자열
    const category = document.querySelector('select').value

    const arr = price.value.split('')
    console.log(arr)
    let tr = document.createElement('tr')

    let td1 = document.createElement('td')
    td1.innerText = product.value

    let td2 = document.createElement('td')
    for(let i = 0; i < arr.length; i++){
        if(i == 0) {
            arr[i] += ','
        }
        td2.innerText += (arr[i])  
        
    }
    td2.innerText += '원'
    //td2.innerText = price.value.slice(0,1) + ',' + price.value.slice(1,4)+ '원'

    // 앞에서 이미 value를 불어왔기 때문에 따라 value를 두번 붙일 필요는 없다
    let td3 = document.createElement('td')
    td3.innerText = category

    // tr에 td넣기
    tr.appendChild(td1)
    tr.appendChild(td2)
    tr.appendChild(td3)

    // tbody에 tr 넣기
    tbody.appendChild(tr)

    // 값 콘솔로그로 확인하기
    console.log(product.value)
    console.log(price.value)
    console.log(category)

    // 값 지우기
    product.value = ''
    price.value = ''
    document.querySelector('option').selected = 'selected'

    // 입력이 끝나면 product로 돌아가라
    product.focus()
}
// document.querySelector('input[type="button"]').onclick = () => {
//     console.log(document.querySelector('select').value)
//     document.querySelector('option').selected = 'selected'
// }

// 이벤트 함수 호출
button.onclick = buttonClickhandler
====================================================


// 필요한 요소 불러오기
const children = document.querySelector('.form').children
console.log(children)

const button = document.querySelector('input[type="button"]')
const tbody = document.querySelector('tbody')


// 호출 함수 선언
const buttonClickhandler = () =>{
    const product = document.querySelector('input[name="product"]')
    const price = document.querySelector('input[name="price"]')
    // category 자체가 value를 포함하기 때문에 문자열
    const category = document.querySelector('select').value

    const arr = price.value.split('')
    console.log(arr)
    let tr = document.createElement('tr')

    let td1 = document.createElement('td')
    td1.innerText = product.value

    let td2 = document.createElement('td')
    for(let i = 0; i < arr.length; i++){
        if(i == 0) {
            arr[i] += ','
        }
        td2.innerText += (arr[i])  
        
    }
    td2.innerText += '원'
    //td2.innerText = price.value.slice(0,1) + ',' + price.value.slice(1,4)+ '원'

    // 앞에서 이미 value를 불어왔기 때문에 따라 value를 두번 붙일 필요는 없다
    let td3 = document.createElement('td')
    td3.innerText = category

    // tr에 td넣기
    tr.appendChild(td1)
    tr.appendChild(td2)
    tr.appendChild(td3)

    // tbody에 tr 넣기
    tbody.appendChild(tr)

    // 값 콘솔로그로 확인하기
    console.log(product.value)
    console.log(price.value)
    console.log(category)

    // 값 지우기
    product.value = ''
    price.value = ''
    document.querySelector('option').selected = 'selected'

    // 입력이 끝나면 product로 돌아가라
    product.focus()
}
// document.querySelector('input[type="button"]').onclick = () => {
//     console.log(document.querySelector('select').value)
//     document.querySelector('option').selected = 'selected'
// }

// 이벤트 함수 호출
button.onclick = buttonClickhandler

====================================================
자바스크립트 -> Document Object -> Window Object
자바스크립트 탄생 -> 전송하는 데이터에 대한 유효성 검사의 필요성

inline 방식은 태그에 직접 자바스크립트를 기술하는 방식이다. 
장점은 태그에 연관된 스크립트가 분명하게 드러난다는 점이다. 
하지만 정보와 제어가 섞여 있기 때문에 정보로서의 가치가 떨어진다
(유지보수가 어렵기 때문이다)

<input type="button" onclick="alert('hello')" value="hello world">

onclick은 HTML문법이고 alert은 javascript문법인데 어떻게 작동할까??
-> onclick안에는 javascript가 들어간다고 약속을 했기 때문이다

script태그가 나오면 자바스크립트가 나온다는 것을 약속  / script는 일단 HTML태그이다

    <script src="./script.js">

    </script>

-> HTML의 정보로써의 가치가 더욱 높아진다

-> 유지보수 편리성 / 결합도 낮춤 / 브라우저 캐시를 줄여줄 수 있다 
-> 이미 다운로드받은 파일을 가지고 있는데 js를 미리 다운받으면 서버쪽에 부담을 줄여줄 수 있다 
-> 서버와 클라이언트가 주고 받는 데이터의 양을 줄여준다

-> script를 head 태그에 위치시킬 수도 있다. 하지만 이 경우는 오류가 발생한다.
-> 상단에 걸어두면 해당 태그를 찾을 수 없다 그래서 null을 발생시킴

해결방법
    <script>
        window.onload = function(){
            var hw = document.getElementById('hw');
            hw.addEventListener('click', function(){
                alert('hello world');
            })
        }
    </script>

-> window.onload를 해주면 모든 문서를 다 다운로드한 후에 해당 function을 로드하겠다는 의미라서 작동이 된다
(이 경우는 head에 스크립트를 작성할 때만 하면 된다/ 스크립트를 바닥에 작성하면 따로 window.onload를 안해도 된다)

===============================

Object Model
웹브라우저의 구성요소들은 하나하나가 객체화되어 있다. 자바스크립트로 이 객체를 제어해서 웹브라우저를 제어할 수 있게 된다. 
이 객체들은 서로 계층적인 관계로 구조화되어 있다. BOM과 DOM은 이 구조를 구성하고 있는 가장 큰 틀의 분류라고 할 수 있다.

window -> (DOM, BOM, JavaScript)

각각의 태그들을 객체로 만들어두고 준비하고 있는 것이다
그래서 그 객체를 찾아서 제어할 수 있다 / 객체가 가리키는 태그를 제어할 수 있고 프로퍼티를 사용할 수 있고 메서드를 사용할 수 있다

객체를 통해서 브라우저를 제어할 수 있다

var imgs = document.getElementByTagName('img');
-> 이것을 객체화라고 한다

윈도우 : 전역객체, window frame을 제어하기 위한 객체
프로퍼티 - DOM(document) BOM(navigator, screen, location, frames,..) JavaScript(Object, Array..)

document 객체가 하는 역할은 웹 페이지의 문서를 제어하는 역할 
Document Object Model   Browser Object Model  JavaScript Core (BW, GAS, Node.js..)

-> 자바스크립트를 통해 브라우저를 제어

// 자바스크립트 10대 에러
https://blog.meeta.io/10


BOM(Browser Object Model)이란 웹브라우저의 창이나 프래임을 추상화해서 프로그래밍적으로 제어할 수 있도록 제공하는 수단이다. 
BOM은 전역객체인 Window의 프로퍼티와 메소드들을 통해서 제어할 수 있다. 

전역객체 window
-> window 객체는 식별자 window를 통해서 얻을 수 있다. 또한 생략 가능하다
-> 변수가 함수에 소속되어 있지 않으면 전역변수가 된다 -> window객체의 프로퍼티를 만드는 것이다

사용자와 커뮤니케이션 하기
-> HTML은 form을 통해서 사용자와 커뮤니케이션할 수 있는 기능을 제공한다. 
자바스크립트에는 사용자와 정보를 주고 받을 수 있는 간편한 수단을 제공한다

alert -> 경고찬이라고 부른다. 사용자에게 정보를 제공하거나 디버깅등의 용도로 많이 사용한다
-> 확인을 누르기 전까지 다음행동이 작동하지 않는다

confirm -> 확인을 누르면 true, 취소를 누르면 false를 리턴한다
    <input type="button" value="localconfrim" onclick="func_confirm();">

    <script>
        function func_confirm(){
            if(confirm('ok?')){
                alert('ok');
            }
            else{
                alert('cancel');
            }
        }
    </script>
-> 조건문 처럼 사용할 수 있다

prompt -> 사용자가 입력한 값을 받아서 자바스크립트가 얻어낼 수 있는 것
        function func_prompt(){
            if(prompt('id') === 'hi'){
                alert('welcome');
            }
            else{
                alert('fail');
            }
        }

Location 객체
Location 객체는 문서의 주소와 관련된 객체로 Window 객체의 프로퍼티다. 
이 객체를 이용해서 윈도우의 문서 URL을 변경할 수 있고, 문서의 위치와 관련해서 다양한 정보를 얻을 수 있다.
-> 보이지 않는 정보에 대해서도 객체화할 수 있다

현재 윈도우의 URL 알아내기
아래는 현재 윈도우의 문서가 위치하는 URL을 알아내는 방법이다. 
console.log(location.toString(), location.href);

URL Pasring
location 객체는 URL을 의미에 따라서 별도의 프로퍼티로 제공하고 있다. 
console.log(location.protocol, location.host, location.port, location.pathname, location.search -> ?뒤에 내용, location.hash -> #뒤에 내용)

http(protocol)://open.org(host):80(port)/module(pathname)/1?id=1(search)/#hash(hash)


URL 변경하기
location.href = 'http://egoing.net';
-> 현재 문서를 해당 url로 이동한다
location = 'http://egiong.net'; -> 동일함
--> 다른 url로 이동시켜야 하는 경우에 사용한다

location.reload(); -> 현재 문서를 리로드하는 간편한 방법을 제공한다

Navigator 객체
브라우저의 정보를 제공하는 객체이다. 주로 호환성 문저등을 위해서 사용한다
console.dir(navigator);

크로스브라우징 -> 브라우저마다 다르게 작동하는 것을 말한다
자바스크립트 ->넷스케이프에서 만든 것이다

넷스케이프에서는 addEventListener를 사용하고 IE에서는 attachEvent를 사용해야 했다
-> 그래서 웹 표준이 나왔다 -> 같은 기능이면 같은 이름을 사용하도록 함
-> 그래서 크로스브라우징이 나옴 -> navigator객체를 사용해서 확인한다
-> 해당 브라우저의 특성을 확인하려면 console.dir(navigator);를 통해서 확인한다

console.dir(navigator.appName); -> netscape라고 뜬다

console.dir(navigator.appVersion)
-> 브라우저의 버전을 의미한다. 

console.dir(navigator.userAgent)
-> 브라우저가 서버측으로 전송하는 user-agent-http 해더의 내용이다.

console.dir(navigator.platform)
-> 운영체제 정보


기능 테스트
navigator 객체는 브라우저 호환성을 위해서 주로 사용하지만 모든 브라우저에 대응하는 것은 
쉬운 일이 아니므로 기능 테스트를 사용하는 것이 더 선호되는 방법이다
Ex) Object.keys라는 메소드를 객체의 key값을 배열로 리턴하는 Object의 메소드이다.
이 메소드는 ECMAScript5에 추가되었기 때문에 오래된 자바스크립트외는 호환되지 않는다.


창 제어
window.open 메소드는 새 창을 생성한다. 대부분의 브라우저는 탭을 지원하기 때문은 window.open은 새 창을 만든다


=======================================================================

================================================================

// slider.style.marginLeft = '-400px'  // margin-left , css에서 -가 들어가는 속성은 camelCase로 변환

================================================================

let value = 0       // 값이 변해야 하는 값이면 let
const unit = 1920    // 변하지 않는 값은 const

===============================================================

<script>
        // 한줄 주석
        /* 
            범위 주석
        */

        // 변수 선언
        
        n1 = 10;
        var n2 = 20;		    // n2는 객체에 대한 이름이다 데이터를 박스로 감싸서 참조하는 이름이 n2이다
				    // 자바스크립트는 wrapper클래스만 가지고 있다
				    // wrapper클래스와 wrapping 방식
				    // var x = 3 -> var x = new Number(3)으로 되는 것이다
        let n3 = 30;                // 값이 변하는 변수면 let      레퍼런스타입
        const n4 = 40;              // 값이 변하지 않는 변수 const 프리미티브타입
        const word = 'hello';       // 대입되는 값의 자료형에 따라서 자동으로 설정된다
        
        // 함수선언
        function func1(){
            console.log('함수1')
        }

        const func2 = function(){   // 자바스크립트의 함수는 그 자체로 객체 취급 된다
            console.log('함수2')    // 자바처럼 함수형 인터페이스 객체가 아니라
        }                          //  함수 자체로 매개변수로 전달할 수 있다

        console.log(n1,n2,n3,n4);
        
        // 함수 호출
        func1();
        func2();

        const arr = [10,20,30,40,50];   // {}가 아니고 []로 배열을 표현한다
                                        // 배열이 리스트처럼, 컬랙션처럼 함수를 가진다
        arr.forEach(function(num){
            console.log(num)    
            // arr안에 있는 각각의 요소를 num이라고 할때, 
            //그 num의 값을 콘솔 창에 출력 (num에 var는 사용불가)
        });

        setInterval(func2, 1000);   
        // 만들어진 함수를 전달해서 사용한다 
        // 시간 간격을 주고 출력한다 
        // 함수를 객체취급해서 전달할 수 있다

        console.log(typeof n1)
        console.log(typeof word)
        console.log(typeof func2)
        console.log(typeof arr)
    </script>

===========================================================

<script>
        // 배열 
        const arr = [40,20,30,'40',11];
        console.log(arr);
        // 자바스크립트 객체를 하나하나 다 볼 수 있다 -> console.log을 장점

        arr.sort();

        // () -> 매개변수를 나타냄
        // 자바스크립트의 arrow function

        // func1은 요소와 인덱스를 콘솔로그에 출력해주라는 함수이다
        const func1 = (element,index) => {
            console.log(element,index)
        };

        // 이제 func1이 arr배열을 돌면서 요소와 인덱스를 콘솔로그에 출력하게 된다
        arr.forEach(func1)
        
        // document에서 selctorAll 하겠다 .image라는 selector를 
        // .image를 가져온다
        const imageList = document.querySelectorAll('.image')
        // 콘솔로그로 출력한다
        console.log(imageList)

        // foreach를 통해서 .image로 가져온 요소에 스타일 한번에 적용할 수 있다
        imageList.forEach(img => {      // 화살표 함수의 매개변수가 1개라면 () 생략 가능
            img.style.border = '3px soild black'
        });
        // 문서의 특정요소를 불러와서 한꺼번에 작업을 진행할 수 있다

        // 화살표 함수의 실행 코드가 한줄이라면 ()생략 가능

        //imageList.forEach(img => img.style.borderRadius = '50%')

        imageList.forEach(img => img.style.borderRadius = '70px')
        // 이렇게 하면 이미지에는 인라인스타일로 적용이 된다
    </script>

==================================================================
    <script>
        // css 선택자를 이용해서 요소를 불러올 수 있다

        document.getElementById('id')           // 지정한 id를 가지느 요소 하나를 반환
        document.querySelector('css선택자')     // 지정한 선택자에 해당하는 요소 중 첫번째 요소 하나만
        document.querySelectorAll('css선택자')  // 지정한 선택자에 해당하는 모든 요소를 nodeList로 반환
        
        // 1) 이름 나이 전화번호가 적혀있는 첫번째 줄의 칸 배경색을 #dadada로 변경하기
        const headList = document.querySelector('thead')
        

        // for(let i = 0; i < headList.length; i++){
        //  const th = headList[i]
        //  th.style.backgroundColor = '#dadada'
        //} -> 기본 for문으로 돌려도 된다
        console.log(headList)

        // css에서 하이픈을 사용하려면 여기서는 camelCase를 적용해서 해야한다
        // don`t forget camelCase
        headList.style.backgroundColor = '#dadada'

        // 2) 각 나이가 적혀있는 칸을 불러와서 내부 텍스트에 '살' 이라는 문자를 추가한다

        const ageList = document.querySelectorAll('tbody>tr>td:nth-child(2)')

        console.log(ageList)

        ageList.forEach(td => {
            td.style.color = 'blue'
            td.style.textAlign = 'center'
            // td.innerText += '살'  -> 기존의 것에 살을 더해주는 것이다
            td.append('살')
        })
        // 3) 전화번호가 적혀있는 칸에 마우스를 올리면 링크처럼 손가락모야응로 나타나도록 설정하세요
    
        const cursor = document.querySelectorAll('tbody>tr>td:nth-child(3)')

        console.log(cursor)

        cursor.forEach(td =>{
            td.style.cursor = 'pointer'
            td.style.textDecoration = 'underline'
        })

        // 4) 이름 bold 처리

        const nameList = document.querySelectorAll('tbody>tr>td:nth-child(1)')

        console.log(nameList)

        nameList.forEach(td =>{
            td.style.fontWeight = 'bolder'
        })
    </script>
================================================================================

<!--
        display : flex로 지정한 요소는
        자신이 아닌, 내부 요소를 기준에 따라서 정렬하는 요소이다

        main axis(기본 축) 와 cross axis(교차 축)에 따라 정렬을 수행한다

        justify-content 속성으로 main축 기준 정렬 위치를 지정할 수 있다
        flex-start : 축의 시작지점쪽으로 요소를 배치한다
        flex-end : 축의 끝점 쪽으로 요소를 배치한다
        center : 축의 가운데를 기준으로 배치한다
        space-between : 축의 시작점과 끝점에 양긑 요소를 배치하고 간격을 두며 배치한다

        flex-flow 속성으로 축을 교차시키거나, 범위를 벗어날 경우 처리를 변경할 수 있다
        flex-flow 기본값을 row이다 

        flex-flow : row     default값
        flex-flow : column  main축이 위에서 아래로 내려오는 방향으로 바뀐다
        flex-flow : wrap    범위를 벗어나면 자동으로 다음 위치로 변경된다
        flex-flow : column wrap-reverse    오른쪽 위에서부터 채운다
    -->
===================================================================

    <input name="n1" type="number" min="0" max="9" value="1"> + 
    <input name="n2" type="number" min="0" max="9"> 
    <button id="btn">=</button>
    <span id="answer"></span>
    
    <script>
        // const n1은 document에서 input태그의 이름이 n1인 것을 찾아서 가져온다
        const n1 = document.querySelector('input[name="n1"]')
        // const n2는 document에서 input태그 중에서 이름이 n2인 것을 찾아서 가져온다
        const n2 = document.querySelector('input[name="n2"]')
        // const btn은 document에서 id가 btn인 것을 찾아서 가져온다
        const btn = document.getElementById('btn')
        // const answer는 document에서 id가 answer인 것을 찾아서 가져온다 
        const answer = document.getElementById('answer')

        // 자바에서 getter를 사용해서 값을 가져오는거랑 유사..?

        const name = "이지은";
        const age = 29;
        const data = name + '님은 ' + age + '살입니다'
        // document.writeln()은 println과 동일하다
        document.writeln(data)
        // 콘솔로그로 data를 출력한다
        console.log(data)
        // 경고창으로 data를 출력한다
        alert(data)

        console.log(document)


        // btn을 클릭했을 때 function이 동작한다
        // const answerValue는 n1의 정수값과 n2의 정수값을 더한 값을 가진다
        // 그리고 answer.innerText로 값을 삽입한다
        // 기존의 값에 추가하려면 answer.innerText += answerValue라고 하면 된다
        btn.onclick = function() {
            const answerValue = +n1.value + +n2.value
            answer.innerText = answerValue
        }
    </script>

=====================================================================

    var x = 4;
        var y = new Number(4);
        var z;
        z = 3;
        alert(typeof z);
        // 어떤 메서드를 사용할 수 있는지는 할당되는 객체에 따라서 달라진다

=====================================================================
element.innerText;

이 속성은 element 안의 text 값들만을 가져옵니다.


element.innerHTML;

innerText와는 달리 innerHTML은 element 안의 HTML이나 XML을 가져옵니다


element.innerText = "<div style='color:red'>A</div>";

element.innerText에 html을 포함한 문자열을 입력하면, 

html코드가 문자열 그대로 element안에 포함됩니다.

 

element.innerHTML = "<div style='color:red'>A</div>";

위와 같이 element.innerHTML 속성에 html코드를 입력하면,

html element가 element안에 포함되게 됩니다.

위 예제에서 'innerHTML()'을 클릭하면,

입력된 html태그가 해석되어 빨간색A 가 나타나는 것을 확인 할 수 있습니다.

===================================================================

// 호출할 함수 선언
const registHandler = () => {
    // 사용자가 입력한 값을 가져와서 테이블에 넣기
    const tdArr = []

    for(let i = 0; i < 3; i++) {
        // 자바의 list처럼 늘어날 수 있다
        tdArr.push(document.createElement('td'))    // 배열에 특정 요소를 추가하는 함수
    }

    tdArr[0].innerText = product.value
    tdArr[1].innerText = price.value
    tdArr[2].innerText = category.value

    const tr = document.createElement('tr')
    tdArr.forEach(td => tr.appendChild(td))
    document.querySelector('tbody').appendChild(tr)

    product.value = ''
    price.value = ''
    // category.firstChild.selected = 'selected'    // 글자를 포함한 모든 요소
    category.firstElementChild.selected = 'selected'// Element로 취급되는 요소로 한정(태그)

    product.focus()
}

// 이벤트 함수 연결
button.onclick = registHandler

==============================================================


// 필요한 요소 불러오기
const children = document.querySelector('.form').children
console.log(children)

const button = document.querySelector('input[type="button"]')
const tbody = document.querySelector('tbody')


// 호출 함수 선언
const buttonClickhandler = () =>{
    const product = document.querySelector('input[name="product"]')
    const price = document.querySelector('input[name="price"]')
    // category 자체가 value를 포함하기 때문에 문자열
    const category = document.querySelector('select').value

    const arr = price.value.split('')
    console.log(arr)
    let tr = document.createElement('tr')

    let td1 = document.createElement('td')
    td1.innerText = product.value

    let td2 = document.createElement('td')
    for(let i = 0; i < arr.length; i++){
        if(i == 0) {
            arr[i] += ','
        }
        td2.innerText += (arr[i])  
        
    }
    td2.innerText += '원'
    //td2.innerText = price.value.slice(0,1) + ',' + price.value.slice(1,4)+ '원'

    // 앞에서 이미 value를 불어왔기 때문에 따라 value를 두번 붙일 필요는 없다
    let td3 = document.createElement('td')
    td3.innerText = category

    // tr에 td넣기
    tr.appendChild(td1)
    tr.appendChild(td2)
    tr.appendChild(td3)

    // tbody에 tr 넣기
    tbody.appendChild(tr)

    // 값 콘솔로그로 확인하기
    console.log(product.value)
    console.log(price.value)
    console.log(category)

    // 값 지우기
    product.value = ''
    price.value = ''
    document.querySelector('option').selected = 'selected'

    // 입력이 끝나면 product로 돌아가라
    product.focus()
}
// document.querySelector('input[type="button"]').onclick = () => {
//     console.log(document.querySelector('select').value)
//     document.querySelector('option').selected = 'selected'
// }

// 이벤트 함수 호출
button.onclick = buttonClickhandler

=============================================================

        // id를 이요해서 요소 불러오기
        const name = document.getElementById('name')
        // css선택자를 이용해서 요소 불러오기
        const age = document.querySelector('#age')

        const year = document.getElementById('year')

        const btn = document.getElementById('btn')
        const result = document.querySelector('.result')

        console.log(btn)            // HTML 태그만 출력
        console.log({'btn' : btn})  // HTML 요소의 내부 상세 정보를 출력

        const btnHandler = (event) => {  // [버튼을 클릭하면] 작동하게 만들 함수를 작성
            console.log(event)
            console.log(event.target)

            console.log(name.value)     // element.property 요소.속성의 형식으로 값에 접근할 수 있다
            console.log(age.value)
            console.log(year.value)
            console.log(name.type)

            if(name.value == '' || age.value == '' || year.value==''){
                alert('모든 값을 입력해주세요')
                return
            }

            // 이 방식은 이클립스에서 사용이 불가능하다
            const str = `${name.value}님은 ${year.value}생이고 ${age.value}살이고, ${age.value >= 20 ? '성인' : '미성년자'}입니다`

            result.innerText = str
            // == : 타입이 달라도, 값의 형태가 일치하면 일치로 판단
            // === : 타입도 같고, 값도 같아야 일치로 판단

            const str2 = name.value + '님은' +
                        age.value + '살이고, '+
                        (age.value >= 20 ? '성인' : '미성년자') + '입니다'
            
            alert(str2)
        }

        btn.onclick = btnHandler    // 버튼을 클릭하면 지정한 함수가 실행되도록
                                    // 함수를 지금 호출하는 것이 아니므로, btnHandler()형식이 아니다
        // 콘솔로그창에 PointerEvent가 발생한다

===================================================================

        // 정수를 입력받아서 자릿수를 거구로 배치하고 result태그 내 출력하기
        const num = document.getElementById('num')
        const btnStr = document.getElementById('btnStr')
        const btnNum = document.getElementById('btnNum')
        const result = document.querySelector('.result')

        const btnHandler = (event) =>{
            // num.value의 값도 let으로 만들어서 사용해야 한다
            let value = +num.value    // Integer.parseInt(value)랑 동일함
            let ans = 0                 // 값을 변경해야 하므로 let

            console.log(value)
        
            while(true){
                ans += (value % 10)
                ans *= 10
                value /= 10                 // /= 을 안해줌
                value = Math.floor(value)   // 소수점을 버리는 함수
                if(value < 10){
                    ans += value
                    break
                }
            }
            
            // ans += (num.value % 10)
            // console.log(ans)

            // ans *= 10
            // console.log(ans)

            // ans += (num.value / 10)

            // console.log(num.value)

            // if(num.value < 10){
            //     ans += num.value
            // }

            console.log(value)
            console.log(ans)


            const str = ans + '입니다'
            
            result.innerText = str
        }

        btnNum.onclick = btnHandler
        

        btnStr.onclick = () => {
            const value = num.value
            var name = num.value
            var reverseName = name.split('').reverse().join('')
            // 입력받은 문자열을 글자하나씩 구분해서 뒤집고
            // 다시 연결해서 하나의 문자열로 만듦

            result.innerText = ''   // innerText안에 한번 비워주기
            
            for(let i = value.length-1; i > 0; i--){
                console.log(value[i])
                result.innerText += value[i]
            }
            // 뒤에서부터 한글자씩 result.innerText로 넣는다
            console.log(reverseName)
        }
=======================================================================

    <script>
        const slider = document.querySelector('.slider')
        // let 값 변경된는 변수
        let value = 0       
        // const는 고정값
        const unit = 1920    
        

        function move() {   
            value -= unit
            if(value <= -7680) {
                value = 0
            }
            slider.style.marginLeft = value + 'px'
        }

        setInterval(move, 3000);    
        


        const menuList = document.querySelectorAll('.list')

        const contentList = document.querySelectorAll('.content_img')

        for(let i = 0; i < menuList.length; i++){
            const list = menuList[i]

            // list onclick하면 해당 함수를 실행
            list.onclick = function(){
        
        // 모든 요소에 hidden 추가
        contentList.forEach(element => element.classList.add('hidden'))
        
        // i번째에 hidden 제거
        contentList[i].classList.remove('hidden')
        
        // 모든 요소에 selectedList제거
        menuList.forEach(element => element.classList.remove('selectedList'))
        
        // i번째에 selectedList추가
        list.classList.add('selectedList')
        }
    }


    </script>

=======================================================================


append와 appendChild는 모두 부모 노드에 자식 노드를 추가하는 메서드

append
-> 노드객체나 DOMString('text')을 사용할 수 있다.
-> 또한 한번에 여러 개의 자식 요소를 설정할 수 있다
-> return 값을 반환하지 않는다

노드 객체 사용 예시
const p = document.createElement('div')
const c = document.createElement('p')

p.append(c)

//결과
<div><p></p></div>

문자열 (DOMString) 사용 예시
const p = document.createElement('div')
p.append('append 예시')

//결과
<div>append 예시</div>


appendChild
-> 오직 Node 객체만 받을 수 있다
-> 한번에 오직 하나의 노드만 추가할 수 있다
-> return 값을 반환합니다

문자열(DOMString) 사용 예시
const p = document.createElement('div')
p.appendChild('텍스트')
-> 이러면 에러 발생

return 값 반환
const p = document.createElement('div')
const s = document.createElement('span')

console.log(document.body.appendChild(div))

=======================================================================

배열 객체
push/pop 메서드를 이용한 데이터 관리 : stack

    <script>
        var nums = new Array();
        nums.push(5);	// nums[0] = 5;
        nums.push(10);	// nums[1] = 10;
        nums.push(21);	// nums[2] = 21;

        // pop은 맨 위에 적재된걸 호출하면서 삭제
        var n1 = nums.pop();
        var n2 = nums.pop();
        var n3 = nums.pop();
        alert(nums)

    </script>

배열 객체 초기화

var nums = new Array();
var nums = new Array(5);	// 5개를 만듬
var nums = new Array(5,10,21);	// 방이 3개짜리를 만듬
var nums = new Array(5,10,21,"hello") // 이렇게도 사용가능함
그래서 console.log(typeof nums[3]); 배열 index의 타입을 확인해야한다

var nums = new Array(5,10,21,"hello", new Array(2,3,4));
-> js에서 배열은 모든 값을 담을 수 있기 때문에 주의해야 한다

========================================================================

    <script>
        var nums = new Array(5,10,11,"hello");
        console.log(nums)

        // 1부터 뒤로 지우기
        // nums.splice(1)
        
        //2째 자리에 1개를 지우고 ㄷㄷㄷ를 넣어라
        // nums.splice(2,0,"ㄷㄷㄷ") 이렇게 하면 2번째 자리에 ㄷㄷㄷ를 삽입하게 된다
        nums.splice(2,1,"ㄷㄷㄷ")

        console.log(nums)


    </script>

=======================================================================


정적인 객체 정의와 동적인 객체 정의

c++, c#, Java -> class (클래스를 만들고 생성자를 통해서 객체를 생성)

javascript -> 객체를 만들고 객체의 타입을 정의 (prototype, class)


Object 객체의 Expand Object

키를 기반으로 데이터를 저장해야 할 때

var exam = new Object();

exam.kor = 30;
exam.eng = 50;
exam.mat = 40;
--> 기본적으로 이방법을 사용하는 것이 바람직

키를 이용한 데이터 관리 : Map

var exam = new Object();

exam["kor"] = 30;
exam["eng"] = 40;
exam["mat"] = 50;

========================================================================

Javascript 데이터 객체와 JSON 생성 방법


		JavaScript Object 		JavaScript Object Notation(JSON)
Boolean		var n = new Boolean(true);	var n = true;
Number		var n = new Number(3);		var n = 3;
String		var n = new String("hello");	var n = "hello";
Array		var n = new Array();		var n = [];
Object 		var n = new Object();		var n = {};

var exam = {"kor" : 30, "eng" : 41, "mat":50}

var ar = [3,4,5,6,7,[4,1,3]]

console.log(exam.kor + exam.mat)
console.log(ar[5][1])

JSON의 중첩 표현

중첩된 데이터의 구조도 쉽게 표현할 수 있다

var notices = [
		{"id" : 1, "title" : "hello~"},
		{"id" : 2, "title" : "hello11~"},
		{"id" : 3, "title" : "heww~"}
	]; 

---> 이렇게 중첩적으로 사용할 수 있다

10강 들을 차례

============================================

    <script>
        // 이럴 경우 한칸 띄우고 역슬러쉬해서 배열로 인식하게 만듬
    var data = '[ \
            {"ty_total":null,"ty_care":25868,"sy_kj":null,"sy_total":null,"ty_kh":null,"death":2773,"s_death":769,"jgk_cont_gh":null,"ty_kj":null,"jgk_overseas_gh":null,"sy_kh":null,"recover":324448,"sn_recover":488,"t_hj":353089,"n_hj":1190,"s_hj":115417,"s_recover":103912}, \
            {"ty_total":null,"ty_care":25740,"sy_kj":null,"sy_total":null,"ty_kh":null,"death":2766,"s_death":764,"jgk_cont_gh":null,"ty_kj":null,"jgk_overseas_gh":null,"sy_kh":null,"recover":323393,"sn_recover":258,"t_hj":351899,"n_hj":1423,"s_hj":114962,"s_recover":103424}, \
            {"ty_total":null,"ty_care":25195,"sy_kj":null,"sy_total":null,"ty_kh":null,"death":2745,"s_death":756,"jgk_cont_gh":null,"ty_kj":null,"jgk_overseas_gh":null,"sy_kh":null,"recover":322536,"sn_recover":804,"t_hj":350476,"n_hj":1508,"s_hj":114442,"s_recover":103166} \
        ]';

        eval('var x = 40;');
        console.log(x);

        // 데이터를 파싱하기
        eval("var ar =" + data + ";");

        console.log(ar[0].ty_total)
    </script>

===========================================

    <script>
        var data = {"id":1, title:"aaa"};

        console.log(data.title)

        console.log(data["id"])

        // 변수도 문자열 형태도 되어있지 않으면 파싱을 할 수 없다
        var data2 = JSON.parse ('{"id":3, "title":"bbbb"}');
        console.log(data.title)

        // data3같은 데이터를 위에 처럼 만들어 줄 때
        var data3 = {id:4, title:"ccc"};
        
        var json = JSON.stringify(data3);
    </script>

==========================================

var x = 3;
var y = 3;

document.write(x == y) -> 값이 같은지 확인
document.write(x === y) -> 주소가 같은지 확인
-> true, true 나옴

=========================================

   <script>
        var ar = ["철수", "영희", "맹구","동천"]

        var ob = {id:1, title:"hello",writeid:"newlec"}
        for (var i in ar){
            document.writeln(ar[i])
        }
        // i : key 나옴
        //  ob[i] : value가 나옴
        for(var i in ob){
            document.writeln(i)
        }
    </script>

=========================================

함수를 객체로 받아서 사용가능

var add = new Function("x,y", "return x+y;");
        
document.writeln(add(3,4))

-> var add = function (x,y){
	return x+y;
   };

-> function add (x,y){
	return x+y;
   }

=========================================

    <script>
        // 매개변수 의미 없다 값을 받는 그릇의 의미 X
        // 참조하는 x, y일뿐이다

        var add = function(x,y){
            
            // 가변적인 매개변수
            // 전달된 매개변수의 갯수를 파악할 수 있다
            alert(arguments.length);
            alert(typeof arguments[4])
            return x+y;
        }
        document.writeln(add(16,3,6,3,"hello"))
    </script>

========================================

변수의 가시영역과 전역변수

    <script>
        // 자료형을 선언하지 안흐면 전역변수가 된다
        a = 1   // window.a = 1
        
        // 지역변수가 전역변수보다 우선순위가 높기 때문에 같은 변수라도 
        // 지역변수로 지정된 값이 출력된다
        var a = 3

        {   // 스크립트에서는 중괄호가 변수 영역을 나누지 않음
            var a = 4
        }

        // 함수안에서 사용된 지역변수는 함수안에서만 사용가능
        // 스크립트에서는 함수영역만 변수 영역을 나눔
        alert(a)
    </script>

=====================================

변수 생명주기와 클로저(Closure)

    <script>
        function f1(){
            var a = 1
            // f2가 클로저이다
            // 자원을 묶어버린다
            return function f2(){
                return a;
            }
        }
        var f = f1();
        var a = f();
        alert(a)
    </script>

====================================

최상위 객체인 window 객체

window 객체의 members : 사용자와 상호작용을 위한 기본 도구

대화상자를 이용한 출력 : alert()

대화상자를 이용한 입력 : prompt()

    <script>
        var x = prompt("x값 입력 ",0)
        var y = prompt("y값 입력 ",0)

        x = parseInt(x)
        y = parseInt(y)


        // return parseInt("abc") -> returns NaN
        // return parseInt("12abc") -> returns 12
        // 문자열로 출력
        alert(x+y)

        var answer;
        answer = confirm("정말 삭제하시겠습니까")
        if(answer){
            alert("삭제되었습니다")
        }
    </script>

=============================

스크립트는 페이지가 읽혀질 때 실행

onclick은 이벤트가 발생할 때 실행


<input type="button" name="" id="" value="클릭" onclick="printResult();">
    <span onclick="alert('hello');">스팬입니다</span>
    <script>
        function printResult(){

        
        var x = prompt("x값 입력 ",0)
        var y = prompt("y값 입력 ",0)

        x = parseInt(x)
        y = parseInt(y)


        // return parseInt("abc") -> returns NaN
        // return parseInt("12abc") -> returns 12
        // 문자열로 출력
        alert(x+y)

        var answer;
        answer = confirm("정말 삭제하시겠습니까")
        if(answer){
            alert("삭제되었습니다")
        }
    }
    </script>


===================================

20강 들을 차례

HTML 파일 - load -> Document Object (객체 트리 in memory) - show -> 사용자 인터페이스


 // input 타입은 속성에 value가 있어서 이렇게 사용할 수 있는데
        // span의 경우에는 속성에 value가 없어서 이렇게 사용 불가능
        btnPrint.value = x+y;

        // 그래서 spand같은 경우에는 innerText를 사용

        span1.innerText = x+y;
====================================

btnPrint.onclick = printResult; 
-> 뒤에 괄호를 붙이면 함수를 대입하는 것이 아니라 호출하는 것

    <input type="button" name="" id="" value="클릭"  id="btnPrint">
    <span id="span1" onclick="alert('hello');">스팬입니다</span>
    <script>
        function printResult(){

        
        var x = prompt("x값 입력 ",0)
        var y = prompt("y값 입력 ",0)

        x = parseInt(x)
        y = parseInt(y)


        // return parseInt("abc") -> returns NaN
        // return parseInt("12abc") -> returns 12
        // 문자열로 출력
        //alert(x+y)
        
        // input 타입은 속성에 value가 있어서 이렇게 사용할 수 있는데
        // span의 경우에는 속성에 value가 없어서 이렇게 사용 불가능
        btnPrint.value = x+y;

        // 그래서 spand같은 경우에는 innerText를 사용

        //span1.innerText = x+y;

        var answer;
        answer = confirm("정말 삭제하시겠습니까")
        if(answer){
            alert("삭제되었습니다")
        }
    }
    btnPrint.onclick = printResult;
    </script>

========================================

위에 스크립트를 헤더쪽에 놔두면 오류가 발생하는 이유 
- btnPrint가 선언되어 있는데 읽어오면서 값은 없으니까
- 버튼 객체가 만들어지기 전에 사용하려고 해서 오류가 발생

========================================

<input type="button" value="출력" id="btn-print">

- html에서는 명명규칙이 btn-print로 해야한다

- 그러면 자바스크립트에서 불러올 때 문제가 발생하기 때문에

var btnPrint = document.getElementById('btn-print')로 해서 변환해서 가지고 와야 한다

    <input type="button" name="" id="" value="클릭"  id="btn-print">
    <span id="span1" onclick="alert('hello');">스팬입니다</span>
    <script>
        function printResult(){
        
        // document가 보따리 역할
        var btnPrint = document.getElementById('btn-print')
        
        var x = prompt("x값 입력 ",0)
        var y = prompt("y값 입력 ",0)

        x = parseInt(x)
        y = parseInt(y)

        btnPrint.value = x+y;

      
    }
    function init(){
        btnPrint.onclick = printResult;
    }
    window.onload = init;
    </script>

==============================

여기서 변수를 전역변수로 빼고 싶을건데 바람직한 방법이 아니다

==============================

스크립트를 사용하는 기본 구조

<script>
function printResult()	// 명명할 이유가 없는 함수
{
	var btnPrint = document.getElementById('btn-print')
}

function init()		// 명명할 이유가 없는 함수
{
	btnPrint.onclick = printResult;
}

window.onload = init;

</script>

============================

    <input type="button" name="" id="" value="클릭"  id="btn-print">
    <span id="span1" onclick="alert('hello');">스팬입니다</span>
    <script>
   
    window.onload = function (){
        var btnPrint = document.getElementById('btn-print')

        // 여기서 함수를 바로 대입하니까 굳이 함수의 이름이 필요가 없다
        // 그래서 Printresult라는 이름을 지워도 된다
        // 익명의 함수가 되버림
        btnPrint.onclick = function(){
        
        // document가 보따리 역할
        
        var x = prompt("x값 입력 ",0)
        var y = prompt("y값 입력 ",0)

        x = parseInt(x)
        y = parseInt(y)

        btnPrint.value = x+y;

      
    };
    }
   
    </script>

===========================

익명 함수를 이용한 이벤트 핸들링

23강 들을 차례

<script src="./js/2.js">

로 js코드를 분리해서 사용가능
</script>

<script src="./js/index.js"></script>

이런식으로 스크립트를 여러개 열어버리면 앞에 function이 덮어씌워지는 경우가 발생한다

여러 스크립트 파일을 함께 사용할 때 초기화 함수의 문제

window.onload = function(){ alert('test1') }
window.onload = function(){ alert('test2') }


// addEventListener로 누적해서 사용가능
// 이벤트를 바인딩할 때 addEventListener를 사용가능
->> window.addEventListener("load", function(){
	alert('test1')
});

===========================

    <input type="number" min="1" max="10" id="value1"> +
    <input type="number" min="1" max="10" id="value2"> 
    <input type="button" value="=" id="add">
    <p id="result"></p>

    <script>
        var value1 = document.getElementById('value1')
        var value2 = document.getElementById('value2')
        var add = document.getElementById('add')
        var result = document.getElementById('result')

        add.onclick = function(){
            var x = parseInt(value1.value);
            var y = parseInt(value2.value)

            result.value =  x+y;
          
            result.innerText += result.value
        }
    </script>

25강 들을 차례

========================


 <section id="section2">
        <input type="number" min="1" max="10" id="value1"> +
        <input type="number" min="1" max="10" id="value2"> 
        <input type="button" value="=" id="add">
        <p id="result"></p>
    </section>
    <script>
        var section2 = document.getElementById('section2')
        var input = section2.getElementsByTagName('input')

        var value1 = input[0]
        var value2 = input[1]
        var add = input[2]
        var result = document.getElementById('result')

        add.onclick = function(){
            var x = parseInt(value1.value);
            var y = parseInt(value2.value)

            result.value =  x+y;
          
            result.innerText += result.value
        }
    </script>

===============================

    <section id="section2">
        <input type="number" min="1" max="10" class="value1"> +
        <input type="number" min="1" max="10" class="value2"> 
        <input type="button" value="=" class="add">
        <p class="result"></p>
    </section>
    <script>
        var section2 = document.getElementById('section2')
        // 배열이기 때문에 0번째를 가져온다
        var value1 = section2.getElementsByClassName('value1')[0]
        var value2 = section2.getElementsByClassName('value2')[0]
        var add = section2.getElementsByClassName('add')[0]
        var result = section2.getElementsByClassName('result')[0]       

===============================

문서를 구성하는 노드들의 계보를 표현하는 방법 : 부모 / 자식

childNodes를 이용한 노드 선택


<div class="box">
	<input>
	<input>
</div>

const box = document.querySelector('.box')
const input = box.childNodes[0]

-> childNodes는 주석도 자식으로 인식한다. 빈 공백도 하나의 노드로 인식해서 붙여사용하지 않으면 원하는 위치에 넣기 힘들다

그래서 

children을 사용한다

-> children은 태그형태로 되어있는 것을 자식으로 인식한다. 그래서 공백과 무관하게 태그만 인식해서 자식으로 가져온다

문서를 구성하는 Node의 종류

DocumentType 	-> 	<!DOCTYPE>
Element 	->	<p>
Attr		->	rows="", cols=""
Entity		->	lt, gt, nbsp
EntityReference	->	& ; 
Text		->	태그안에 들어갈 문자
Comment		->	<!-- -->
CDATASection	->	<![CDATA[<,>,]]>
Notation	->	속성의 값 "#ffff00", "10px"

====================

HTML 태그의 속성과 객체의 속성은 거의 일치


<input class="src-input" list="img-list">
<datalist id="img-list">
	<option value="img1.jpg">img1</option>
	<option value="img2.jpg">img2</option>	
	<option value="img3.jpg">img3</option>
</datalist>

-> 이렇게 하면 input타입에서도 select처럼 사용할 수 있다

===================

txt1.style.width = '100px' -> 이렇게 줘야한다 뒤에 px빼먹으면 안됨

txt1.style.["border-color"] = img.value

txt1.stylw.borderColor = img.value 이렇게 두 가지 방식으로 지정할 수 있다

console.log(img.className) -> class는 예약어라서 바로 사용이 안되서 className으로 줘야지 사용가능하다

===================

div.appendChild(txtNode)

div.removeChild(txtNode) -> 이런식으로 append를 할 수 있고, remove를 할 수 있다

===================

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .content {
            display: flex;
            flex-flow: wrap;
            width: 700px;
            margin: auto;
        }
        .item {
            margin: 10px;
            padding: 10px;
            border: 2px solid black;
            box-shadow: 5px 5px grey;
            border-radius: 10px;
            width: 300px;
            cursor: pointer;
        }
        .item:hover {
            background-color: rgba(255, 0, 0, 0.1);
        }
        .item > div:first-child {
            display: flex;
            justify-content: center;
        }
        .asc, .desc {
            display: none;
        }
        .usingAsc > .asc, 
        .usingDesc > .desc {
            display: inline;
        }
    </style>
</head>
<body>
    <script>
        // 함수는 상단에 지정해주는 것이 좋다
        function JSONtoHTML(ob){
            const item = document.createElement('div')
            item.classList.add('item')

            for(key in ob){
                const value = ob[key]
                const div = document.createElement('div')
                div.classList.add(key)
                if(key == 'img'){
                    const img = document.createElement('img')
                    img.src = 'img/' + ob.img
                    img.height = 200
                    div.appendChild(img)
                }
                else{
                    div.innerText = key + ':' + value
                }
                item.appendChild(div)
            }
            return item
        }

        function sortFoodArr(event){
            const order = event.target.dataset.order
            const asc = +event.target.dataset.asc
            
            // 부모노드의 자식들(형제 노드 가져오기)
            // forEach가 안되어서 반복문으로
            const brother = event.target.parentNode.children
            for(let i = 0; i < brother.length; i++){
                const element = brother[i]
                element.classList.remove('usingAsc')
                element.classList.remove('usingDesc')
            }
            event.target.classList.add((+asc > 0 ? 'usingAsc' : 'usingDesc'))

            // 정렬하고 정렬 순서 뒤집고 기존 내용 제거하고 화면에 띄우기
            arr.sort((a,b) => (a[order] > b[order] ? 1 : -1) * asc)
            event.target.dataset.asc = -asc
            content.innerHTML = ''
            showFoodList()
        }

        // 음식 목록을 화면에 띄우는 함수
        function showFoodList(){
            arr.forEach(food => {
                const div = JSONtoHTML(food)
                content.appendChild(div)
            })
        }
    </script>
    
    <div id="root">
        <div class="sortMenu">
            <button class="sortBtn" data-order="name" data-asc="1">
                메뉴 이름 순
                <span class="asc">▲</span>
                <span class="desc">▼</span>
            </button>
            <button class="sortBtn" data-order="price" data-asc="1">
                가격 순
                <span class="asc">▲</span>
                <span class="desc">▼</span>
            </button>
        </div>
        <div class="filetrMenu">
            <label><input class="filtered" type="checkbox" data-pri="10000">1만원대</label>
            <label><input class="filtered" type="checkbox" data-pri="20000">2만원대</label>
            <label><input class="filtered" type="checkbox" data-pri="30000">3만원대</label>
            <label><input class="filtered" type="checkbox">전체</label>
        </div>
    </div>
    <div class="content"></div>

    <script>
        const arr =[
            {
                img : '돈까스.png',
                name : '돈까스',
                price : 20000
            },
            {
                img : '떡볶이.jpg',
                name : '떡볶이',
                price : 40000
            },
            {
                img : '로제떡볶이.jpg',
                name : '로제떡볶이',
                price : 16000
            },
            {
                img : '어묵탕.jpg',
                name : '어묵탕',
                price : 14500
            },
            {
                img : '쫄면.jpg',
                name : '쫄면',
                price : 17000
            }
        ]
        console.log(arr)

        // 이벤트 대상을 불러와서 이벤트 함수를 연결
        const sortMenu = document.querySelector('.sortMenu')
        const content = document.querySelector('.content')

        // 배열의 데이터를 (원하는 기준으로 정렬하여) 화면에 출력
        const btnList = document.querySelectorAll('.sortBtn')
        btnList.forEach(btn => btn.addEventListener('click', sortFoodArr))

        // 문서 로딩이 끝나면 실행할 함수
        window.onload = showFoodList
    </script>

    <script>
        // 자바스크립트 객체 <=> 문자열 변환
        const jsonString = JSON.stringify(arr)
        const jsonObject = JSON.parse(jsonString)
        // console.log(jsonString)
        // console.log(jsonObject)
    </script>

    <script>
        const fd = document.querySelectorAll('.filtered')
        console.log(fd)
        fd.forEach(btn =>{
            btn.onclick = function(){
                const pri = btn.dataset.pri
                console.log(pri)
                let p1 = arr.filter(ob => ob.price >= pri)
                console.log(p1)
                content.innerHTML = ''

                p1.forEach(bt =>{
                    const p11 = JSONtoHTML(bt)
                    content.appendChild(p11)
                })
                               
            }
        })
        function filterArr(event){
            const pri2 = event.target.dataset.pri
            let filterNewArr = arr.filter(ob => ob.price >= pri2)

            filterNewArr.forEach(btn =>{
                const 
            })
        }
    </script>
</body>
</html>